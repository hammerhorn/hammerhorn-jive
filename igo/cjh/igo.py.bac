#!/usr/bin/python/
# coding=UTF-8

import os, textwrap, time

from cjh.shell import Cli, Enumeration, ItemList, ListPrompt, Thing
from cjh.geometry import Graph, Point


class Goban(Graph):
    """
    a crude graphing calculator in the shape of a go board
    """
    def __init__(
        self, size=19, skinfile='unicode1.json', sh_obj=Cli(), adjust_ssize=0):
        super(Goban, self).__init__(size, skinfile, sh_obj, adjust_ssize)

    def __getstate__(self):
        state = self.__dict__.copy()
        del state['sh_obj']
        return state

     ###########
     #  BOARD  #
     ###########
    def is_hoshi(self, x, y):
        """
        Return True if the point is a starpoint
        """
        # Convert ordered pair to array indices
        x += self.max_domain
        y = self.max_domain - y

        # Determine starpoint
        if self.size >= 12:
            starpoint = 4
        elif self.size >= 9:
            starpoint = 3
        else: starpoint = 2

        side_point = False
        if self.size % 2 == 1 and self.size >= 13:
            side_point = True

        if x == starpoint - 1 and y == starpoint - 1:
            return True

        if side_point:
            if (x == self.max_domain and y == starpoint - 1) or \
               (x == starpoint - 1 and y == self.max_domain) or \
               (x == starpoint - 1 and y == self.max_domain) or \
               (x == self.size - starpoint and y == self.max_domain) or \
               (x == self.max_domain and y == self.size - starpoint):
                return True

        if (x == self.size - starpoint and y == starpoint - 1) or \
           (x == starpoint - 1 and y == self.size - starpoint) or \
           (x == self.size - starpoint and y == self.size - starpoint):
            return True
        return False

    def access_gnugo_functs(self, basename):
        """
        Scoring/estimating tools from gnugo
        """
        #return_val =
        Cli.make_page(
            'WRITE FILE: {}.sgf'.format(basename), self, lambda: self.write_sgf(
            basename))
        #if return_val != 0: return -1

        menu1 = ListPrompt(['..', 'fast', 'medium', 'slow'])
        sel1 = Cli.make_page('MENU: GNUGO Scoring Tools', self, menu1.input)
        gnugo_dict = {'fast':'estimate', 'medium':'finish', 'slow':'aftermath'}
        print('') #pylint: disable=C0325
        if sel1 != 1:
            os.system('gnugo --score ' + gnugo_dict[menu1.items[sel1 - 1]] +\
                      ' --quiet -l {}.sgf'.format(basename))
            Cli.wait()


     ############
     #  POINTS  #
     ############
    def place_stone(self, letter, number, color):
        """
        Add a stone to the board.  letter, number are the coordinates, color is
        color.
        """
        letter = letter.upper()
        if letter >= 'I':
            ordinal = ord(letter) - 66
        else: ordinal = ord(letter) - 65
        tmp_pt = self.indices_to_point(ordinal, self.size - number) #.tuple()

        x_val, y_val = tmp_pt.x_mag, tmp_pt.y_mag
        self.plot_point(x_val, y_val, color)
        self.cursor = x_val, y_val


class GoGame(Thing):
    header = {}
    moves = []

#    def __init__(self, sgf_str='()', skin='unicode1.json'):
    def __init__(self, header=None, moves=[]):
        super(GoGame, self).__init__()
        self.head_dict = {}
        if header is not None:
            self.header_str = header
            self.moves = moves
            self.head_list = self.header_str.split(']')[:-1]

            for unit in self.head_list:
                l = unit.split('[')
                self.head_dict.update({l[0]:l[1]})

        else: # If this is a new game, there will be no header.  So let's make one.
            black_player = Cli.input("Black player's name: ")
            white_player = Cli.input("White player's name: ")
            #komi = Cli.input("Komi: ")
            self.head_dict.update({'SZ': 19, 'PW': white_player, 'PB': black_player, 'KM': 6.5, 'GM':1})

        print self.head_dict
        Cli.wait()

       # if len(moves) == 0:
            
        
    def __repr__(self):
        s = super(GoGame, self).__repr__()
        #s = Thing().__repr__()
        s += "\nheader: {}".format(self.header)
        s += "\n\n moves: {}".format(self.moves)
        return s

    def __str__(self):
        try:
            for game, index in enumerate(self.game_list):
                self.game_list[index].header = str(game[1]) + "\n"
        except: # type?
            pass

        s = []

        if 'AP' in self.header:
            s += ["SGF generated by {}.".format(self.header['AP'])]

        if 'DT' in self.header:
            s += [self.header['DT']]

        if "GM" in self.header:
            game = ''
            if self.header['GM'] == '1':
                game = 'go'
            else: game = 'unknown'
            s += ["The game is {}.".format(game)]

        if 'RU' in self.header:
            s += ["{} rules".format(self.header['RU'])]

        if 'SZ' in self.header:
            s += ["The board size is {0} Ã— {0}.".format(self.header['SZ'])]

        if 'KM' in self.header:
            s += ["Komi is {}.".format(self.header['KM'])]

        if 'PB' in self.header:
            s += ["Black Player: {}".format(self.header['PB'])]

        if 'PW' in self.header:
            s += ["White Player: {}".format(self.header['PW'])]

        bullets = ItemList(s)
        moves_enum = Enumeration(self.moves)
        return self.ul_label() + str(bullets) + str(moves_enum) +\
            Cli.hrule(string=True, width=40)

    def less(self):
        Cli.less(str(self))

    def play_thru(self, autoplay=False):
        goban = Goban(int(self.header['SZ']), skinfile=self.skin)
        color = 'black'
        for _, v in enumerate(self.moves):
            goban.place_stone(v[0], int(v[1:]), color)
            if autoplay:
                func = lambda: time.sleep(.25)
            else: func = Cli.wait
            Cli.make_page(self.label, str(goban), func)
            if color == 'white':
                color = 'black'
            elif color == 'black':
                color = 'white'


# Cancelled code from constructor:
        #try:
        #    assert len(sgf_str) > 0
        #    assert sgf_str[0] == '(' and sgf_str[-1] == ')'
        #except AssertionError:
        #    pass #sys.stderr.write('Invalid game string\n')
        #elements = sgf_str.split(';')


#        self.moves = [s.split('[')[1].split(']')[0] for s in self.moves]
#        self.moves = [s[0].upper() + s[1] for s in self.moves if len(s) > 0]
#        board_size = int(self.header['SZ'])
#        self.moves = [s[0] + str(board_size - (ord(s[1]) - 97))
#             for s in self.moves]
#        self.skin = skin




class GameRecord(Thing):

    def __init__(self, filename, skin="unicode1.json"):
        super(GameRecord, self).__init__()
        self.buffer_ = Cli.cat(files=[filename], quiet=True, return_str=True)
        self.headers = []
        self.games = []
        unit_list = self.buffer_.split(';')
        header = unit_list[1]
        self.games.append(GoGame(header))
        moves = []
        count = 2
        board = Goban()
        while True:
            address = unit_list[count].split('[')[1][0:2]
            if unit_list[count][0] == 'B': color = 'black'
            elif unit_list[count][0] == 'W': color = 'white'
            if len(unit_list[count]) > 5: comments = unit_list[count][7:-2]
            else: comments = ''
            turn = Turn(color, address, comments)
            board.place_stone(address[0].upper(), ord(address[1]) - 96, color)
            Cli.clear()
            print board
            print '\n' + Cli.term_fx('u', "Turn:") + str(turn)
            count += 1
            Cli.wait()
        #First, strip comments

##        

        #print('buffer = ' + buffer_)

        #zone = None
        #tag = ""
        #for char in list(buffer):
        #    if char == '(' and zone == None:
        #        self.game_count += 1
        #        zone = 'game'
        #    elif char == ';':
        #        if zone == 'game':
        #            zone = 'header'
        #        elif zone == 'header':
        #            zone = 'moves'
        #    else:
        #        if char != '[':
        #            tag += char
        #        elif char != ']':
        #            value += char


##        for i, v in enumerate(self.game_list):
#            Cli.term_fx('\n\nself.game_list[{}] = {}'.format(i, v))
##            Cli.term_fx('bup', '\n\nself.game_list[{}] ='.format(i))
##            print(v) #pylint: disable=C0325
##            Cli.wait()
        #print('game_list = ' + str(self.game_list))

##        self.game_list = [
##            game + ')'  for game in self.game_list if len(game) > 0
##        ]

        #print('game_list = ' + str(self.game_list))

##        string = ''
##        for item in self.game_list:
##            string += item + '\n'

        #print('game_list = ' + string)



##        for index, game in enumerate(self.game_list):
##            self.game_list[index] = GoGame(game, skin)
        #f = open(filename)
        #char = f.read(1)
        #if char == '(': self.game_count += 1
        #header

    def __str__(self):
        s = ''
        for game in self.game_list:
            s += ("\n" + str(game))
        return s

    def __getitem__(self, index):
        return self.game_list[index]

    def __len__(self):
        return len(self.game_list)


class GoStone(Thing):
    def __init__(self, color, pt_tuple):
        super(GoStone, self).__init__()
        self.alive = True
        self.color = color
        self.pt_tuple = pt_tuple



class Turn(Thing):
    def __init__(self, color, pt_tuple, comments):
        #self.point = Point()
        self.address = pt_tuple
        self.color = color
        self.comments = comments

    def __remove_captured_stones():
        pass

    def __str__(self):

        commentsf = textwrap.fill(self.comments, replace_whitespace=False, width=45)
#        commentsf = self.comments
        return self.address + '\n' + self.color + '\n\n' + commentsf + '\n'


class Group(Thing):
    def __init__(self, seed_stone):
        pass        
